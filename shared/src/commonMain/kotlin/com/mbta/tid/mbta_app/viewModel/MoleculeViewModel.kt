package com.mbta.tid.mbta_app.viewModel

import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.MonotonicFrameClock
import app.cash.molecule.RecompositionMode
import app.cash.molecule.launchMolecule
import com.mbta.tid.mbta_app.repositories.ISentryRepository
import kotlin.time.Duration
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.SupervisorJob
import kotlinx.coroutines.TimeoutCancellationException
import kotlinx.coroutines.channels.BufferOverflow
import kotlinx.coroutines.flow.MutableSharedFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.withTimeout

public expect abstract class MoleculeScopeViewModel() {
    internal val scope: CoroutineScope
}

/**
 * A generic Molecule view model, consuming [Event]s and returning a [StateFlow] of [Model]s.
 *
 * Implementers should reexpose `val models get() = internalModels` and provide wrappers for
 * `fireEvent` for the types of event that they offer.
 */
public abstract class MoleculeViewModel<Event, Model> : MoleculeScopeViewModel() {
    private val events =
        MutableSharedFlow<Event>(
            replay = 20,
            extraBufferCapacity = 10,
            onBufferOverflow = BufferOverflow.SUSPEND,
        )

    internal class TimeoutException(
        className: String?,
        event: Any?,
        timeout: TimeoutCancellationException,
    ) : Exception("Timeout in $className handling event $event", timeout)

    @Composable
    protected fun EventSink(
        eventHandlingTimeout: Duration,
        sentryRepository: ISentryRepository,
        handleEvent: suspend (Event) -> Unit,
    ) {
        LaunchedEffect(null) {
            events.collect { event ->
                try {
                    withTimeout(eventHandlingTimeout) { handleEvent(event) }
                } catch (exc: TimeoutCancellationException) {
                    sentryRepository.captureException(
                        TimeoutException(this@MoleculeViewModel::class.simpleName, event, exc)
                    )
                }
            }
        }
    }

    /**
     * The flow of states generated by [runLogic].
     *
     * Unfortunately, Objective-C generics handle nullability in weird ways, so if this is public it
     * gets turned into a StateFlow<Model?>, which is really annoying. As such, this must be
     * reexposed with `val models get() = internalModels` in each individual ViewModel.
     */
    protected val internalModels: StateFlow<Model> by
        lazy(LazyThreadSafetyMode.NONE) {
            scope.launchMolecule(mode = RecompositionMode.ContextClock) { runLogic() }
        }

    internal fun modelsForUnitTests(scope: CoroutineScope, clock: MonotonicFrameClock) =
        CoroutineScope(scope.coroutineContext + SupervisorJob() + clock).launchMolecule(
            RecompositionMode.ContextClock
        ) {
            runLogic()
        }

    protected fun fireEvent(event: Event) {
        if (!events.tryEmit(event)) {
            error("Event buffer overflow in ${this::class}")
        }
    }

    @Composable protected abstract fun runLogic(): Model
}
