package com.mbta.tid.mbta_app.viewModel

import androidx.compose.runtime.Composable
import androidx.compose.runtime.MonotonicFrameClock
import app.cash.molecule.RecompositionMode
import app.cash.molecule.launchMolecule
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.SupervisorJob
import kotlinx.coroutines.channels.BufferOverflow
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.MutableSharedFlow
import kotlinx.coroutines.flow.StateFlow

public expect abstract class MoleculeScopeViewModel() {
    internal val scope: CoroutineScope
}

/**
 * A generic Molecule view model, consuming [Event]s and returning a [StateFlow] of [Model]s.
 *
 * Implementers should reexpose `val models get() = internalModels` and provide wrappers for
 * `fireEvent` for the types of event that they offer.
 */
public abstract class MoleculeViewModel<Event, Model> : MoleculeScopeViewModel() {
    private val events =
        MutableSharedFlow<Event>(
            replay = 20,
            extraBufferCapacity = 20,
            onBufferOverflow = BufferOverflow.SUSPEND,
        )

    /**
     * The flow of states generated by [runLogic].
     *
     * Unfortunately, Objective-C generics handle nullability in weird ways, so if this is public it
     * gets turned into a StateFlow<Model?>, which is really annoying. As such, this must be
     * reexposed with `val models get() = internalModels` in each individual ViewModel.
     */
    protected val internalModels: StateFlow<Model> by
        lazy(LazyThreadSafetyMode.NONE) {
            scope.launchMolecule(mode = RecompositionMode.ContextClock) { runLogic(events) }
        }

    internal fun modelsForUnitTests(scope: CoroutineScope, clock: MonotonicFrameClock) =
        CoroutineScope(scope.coroutineContext + SupervisorJob() + clock).launchMolecule(
            RecompositionMode.ContextClock
        ) {
            runLogic(events)
        }

    protected fun fireEvent(event: Event) {
        if (!events.tryEmit(event)) {
            error("Event buffer overflow in ${this::class}")
        }
    }

    @Composable protected abstract fun runLogic(events: Flow<Event>): Model
}
